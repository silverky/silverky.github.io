<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[CodePod]]></title><description><![CDATA[Think more about coding]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>CodePod</title><link>http://localhost:2368/</link></image><generator>Ghost 3.19</generator><lastBuildDate>Wed, 17 Jun 2020 17:43:21 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Tại sao cần CI/CD?]]></title><description><![CDATA[<p>CI/CD là phương thức liên tục triển khai app đến khách hàng bởi tự động hóa các stage trong quá trình phát triển từ pha integration và testing đến delivery và deployment.</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/06/Screenshot-from-2020-06-16-23-46-25.png" class="kg-image" srcset="http://localhost:2368/content/images/size/w600/2020/06/Screenshot-from-2020-06-16-23-46-25.png 600w, http://localhost:2368/content/images/size/w1000/2020/06/Screenshot-from-2020-06-16-23-46-25.png 1000w, http://localhost:2368/content/images/size/w1600/2020/06/Screenshot-from-2020-06-16-23-46-25.png 1600w, http://localhost:2368/content/images/size/w2400/2020/06/Screenshot-from-2020-06-16-23-46-25.png 2400w"></figure><p>CI là continuous integration, một tiến trình liên tục commit những thay đổi để được built, tested,</p>]]></description><link>http://localhost:2368/ci-cd/</link><guid isPermaLink="false">5ee8f35a33ca56a8cb8f3518</guid><category><![CDATA[ci/cd]]></category><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Wed, 17 Jun 2020 14:01:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/06/gitlab_workflow_example_11_9.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/06/gitlab_workflow_example_11_9.png" alt="Tại sao cần CI/CD?"><p>CI/CD là phương thức liên tục triển khai app đến khách hàng bởi tự động hóa các stage trong quá trình phát triển từ pha integration và testing đến delivery và deployment.</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/06/Screenshot-from-2020-06-16-23-46-25.png" class="kg-image" srcset="http://localhost:2368/content/images/size/w600/2020/06/Screenshot-from-2020-06-16-23-46-25.png 600w, http://localhost:2368/content/images/size/w1000/2020/06/Screenshot-from-2020-06-16-23-46-25.png 1000w, http://localhost:2368/content/images/size/w1600/2020/06/Screenshot-from-2020-06-16-23-46-25.png 1600w, http://localhost:2368/content/images/size/w2400/2020/06/Screenshot-from-2020-06-16-23-46-25.png 2400w" alt="Tại sao cần CI/CD?"></figure><p>CI là continuous integration, một tiến trình liên tục commit những thay đổi để được built, tested, merged vào một branch được shared, để tránh tình trạng conflict khi có nhiều branch đồng thời thay đổi.</p><p>CD là continuous delivery và continuous deployment, mục đích là tăng tốc độ chuyển giao, tăng hiệu quả trao đổi với khách hàng:</p><ul><li>Continous delivery: Sau khi những thay đổi được test ở qúa trình CI, chúng sẽ được tự động upload lên một repo. Mục đích của qúa trình này là có một codebase mới nhất, luôn sẵn sàng cho production.</li><li>Continous deployment: Nói đến việc tự động release những thay đổi từ một repo đến production, là bước tiếp theo của continous delivery.</li><li>Cả 2 pha này cần có một well-designed test automation.</li></ul><p>Ý tưởng chính của toàn bộ qúa trình là liên tục cập nhật một cách tự động những thay đổi nhỏ.</p><p>Một số công cụ phổ biến là Jenkins, GitLab, CircleCI, Travis CI, Atlassian Bamboo.</p>]]></content:encoded></item><item><title><![CDATA[Linux container]]></title><description><![CDATA[<p>Linux container là một tập của nhiều tiến trình được cô lập với phần còn lại của hệ thống. Tất cả các file cần thiết để có thể run các tiến trình đã được đóng gói vào một file, được gọi là <em>image, </em>giúp dễ dàng hơn trong qúa trình</p>]]></description><link>http://localhost:2368/linux-container/</link><guid isPermaLink="false">5ee77a7a8175c8b24858fe7a</guid><category><![CDATA[container]]></category><category><![CDATA[virtualization]]></category><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Mon, 15 Jun 2020 14:56:25 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/06/sql_server_docker_linux_container-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/06/sql_server_docker_linux_container-1.png" alt="Linux container"><p>Linux container là một tập của nhiều tiến trình được cô lập với phần còn lại của hệ thống. Tất cả các file cần thiết để có thể run các tiến trình đã được đóng gói vào một file, được gọi là <em>image, </em>giúp dễ dàng hơn trong qúa trình phát triển từ development, đến testing và cuối cùng là production.</p><p>Hãy tưởng tượng khi bạn phát triển một ứng dụng, nó có thể phụ thuộc vào những thư viện khác, môi trường phát triển của mỗi developer, cũng như môi trường deploy cũng có thể khác nhau. Câu trả lời để khắc phục những khó khăn đó và tăng tốc qúa trình phát triển chính là container.</p><p>Container khác với virtualization như thế nào?</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2020/06/virtualization-vs-containers.png" class="kg-image" srcset="http://localhost:2368/content/images/size/w600/2020/06/virtualization-vs-containers.png 600w, http://localhost:2368/content/images/size/w1000/2020/06/virtualization-vs-containers.png 1000w, http://localhost:2368/content/images/size/w1600/2020/06/virtualization-vs-containers.png 1600w, http://localhost:2368/content/images/size/w2400/2020/06/virtualization-vs-containers.png 2400w" alt="Linux container"><figcaption>Virtualization vs Container</figcaption></figure><ul><li>Virtualization: Sử dụng một hypervisor để gỉa lập phần cứng, cho phép chạy nhiều OS đồng thời trên cùng một phần cứng.</li><li>Container: Chia sẻ cùng nhân và chạy native trên OS, chiếm ít tài nguyên hơn virtualization.</li></ul>]]></content:encoded></item><item><title><![CDATA[Build fault-tolerant microservices]]></title><description><![CDATA[<h2 id="summary">Summary</h2><p>This developer code pattern demonstrates the deployment of a Open Liberty application using Eclipse MicroProfile on Kubernetes. It uses Prometheus to scrape application metrics and the Grafana platform for analytics and monitoring. The application uses MicroProfile Release 2.1 and focuses on fault-tolerance, which is one of the features</p>]]></description><link>http://localhost:2368/build-fault-tolerant-microservices/</link><guid isPermaLink="false">5ee72ac8c6109770d9cb6e0c</guid><category><![CDATA[microservices]]></category><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Mon, 15 Jun 2020 08:01:24 GMT</pubDate><content:encoded><![CDATA[<h2 id="summary">Summary</h2><p>This developer code pattern demonstrates the deployment of a Open Liberty application using Eclipse MicroProfile on Kubernetes. It uses Prometheus to scrape application metrics and the Grafana platform for analytics and monitoring. The application uses MicroProfile Release 2.1 and focuses on fault-tolerance, which is one of the features in that release.</p><h2 id="description">Description</h2><p>All microservices fail, and it’s is important to create resilient microservices. Eclipse MicroProfile Fault Tolerance provides a simple, configurable, and flexible solution to create a fault-tolerant microservice. It offers the following fault-tolerance policies:</p><ul><li><strong>Timeout</strong>: Define a duration for timeout.</li><li><strong>Retry</strong>: Define a criteria on when to retry.</li><li><strong>Fallback</strong>: Provides an alternative solution for a failed execution.</li><li><strong>Bulkhead</strong>: Isolates failures in part of the system while the rest of the system can still function.</li><li><strong>CircuitBreaker</strong>: Offers a way of fast-fail by automatically failing execution to prevent the system overloading and indefinite wait or timeout by the clients.</li><li><strong>Asynchronous</strong>: Invoke the operation asynchronously.</li></ul><p>The main design is to separate execution logic from execution. The execution can be configured with fault-tolerance policies.</p><p>MicroProfile is a baseline platform definition that optimizes Enterprise Java for a microservices architecture and delivers application portability across multiple MicroProfile runtimes. Since the release of MicroProfile 1.2, the metrics feature comes out of the box with the platform.</p><p>The <a href="https://github.com/IBM/sample.microservices.web-app">sample application</a> used is a web application for managing a conference and is based on a number of discrete microservices. The front end is written in Angular; the backing microservices are in Java. All run on Open Liberty, in Docker containers managed by Kubernetes. It’s based on a <a href="https://github.com/eclipse/microprofile-conference">demo application</a> from the MicroProfile platform team. The <a href="https://github.com/IBM/sample.microservices.web-app">fork sample application</a> was converted to use Open Liberty and Microprofile Metrics, which is part of Microprofile Release 2.1.</p><h2 id="flow">Flow</h2><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/patterns/build-fault-tolerant-microservices-with-java/images/flow.png" class="kg-image" alt="flow"></figure><ol><li>Create Kubernetes service in <a href="https://cloud.ibm.com/?cm_sp=ibmdev-_-developer-patterns-_-cloudreg">IBM Cloud</a>.</li><li>Deploy all the microservices into the Kubernetes cluster.</li><li>Deploy Prometheus server as a service into the Kubernetes cluster.</li><li>Deploy Grafana as a service into the Kubernetes cluster.</li><li>Use Ingress gateway to expose the web application from the Kubernetes cluster.</li><li>User accesses the web application through browser.</li></ol><h2 id="instructions">Instructions</h2><p>Ready to get started? See the <a href="https://github.com/IBM/java-microprofile-fault-monitoring/blob/master/README.md">README</a> for step-by-step instructions.</p>]]></content:encoded></item><item><title><![CDATA[Build a secure microservices-based banking application]]></title><description><![CDATA[<h2 id="summary">Summary</h2><p>In this code pattern, we demonstrate the security and orchestration of microservices using a personal banking use-case scenario.</p><h2 id="description">Description</h2><p>In a microservices-based solution, security and orchestration of workflows are common requirements. By using IBM API Connect for OAuth-based authentication and authorization to microservices and by using IBM App Connect</p>]]></description><link>http://localhost:2368/build-a-secure-microservices-based-banking-application/</link><guid isPermaLink="false">5ee72a79c6109770d9cb6e05</guid><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Mon, 15 Jun 2020 08:00:37 GMT</pubDate><content:encoded><![CDATA[<h2 id="summary">Summary</h2><p>In this code pattern, we demonstrate the security and orchestration of microservices using a personal banking use-case scenario.</p><h2 id="description">Description</h2><p>In a microservices-based solution, security and orchestration of workflows are common requirements. By using IBM API Connect for OAuth-based authentication and authorization to microservices and by using IBM App Connect to seamlessly integrate APIs (with zero code) into our application, we can build a secure microservices-based personal banking application that allows users to transfer funds.</p><p>After using this code pattern, you will understand how to:</p><ul><li>Authenticate and authorize using OAuth in API Connect.</li><li>Orchestrate of APIs using App Connect.</li><li>Build and deploy Node.js microservices on <a href="https://www.ibm.com/cloud/kubernetes-service/">IBM Kubernetes Service</a>.</li><li>Develop a client application using Node-RED.</li></ul><h2 id="flow">Flow</h2><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/patterns/build-a-secure-microservices-based-application-with-transactional-flows/images/api-connect-app-connect-arch.png" class="kg-image" alt="Architecture flow for secure microservices-based banking app using API Connect and App Connect"></figure><ol><li>The user logs in to the client application.</li><li>The login request is sent to API Connect.</li><li>API Connect uses the Login API (a microservice deployed on IBM Kubernetes Service that interacts with MongoDB) for authentication and then generates an OAuth token for authorization.</li><li>The user invokes the funds transfer transaction using the OAuth token. The transaction request goes to App Connect, which internally uses <code>Account Management</code> API, <code>Credit Account</code> API and <code>Debit Account</code> API (all of which are microservices deployed on IBM Kubernetes Service and that interact with MongoDB).</li></ol><h2 id="instructions">Instructions</h2><p>Ready to put this code pattern to use? Complete details on how to get started running and using this application are in the <a href="https://github.com/IBM/microservices-using-apiconnect-and-appconnect/blob/master/README.md">README</a>.</p>]]></content:encoded></item><item><title><![CDATA[Design and deliver a REST-based, cloud-native application at lightning speed]]></title><description><![CDATA[<h2 id="introduction">Introduction</h2><p>For a software delivery project to be successful, alignment is required across multiple enterprise disciplines, such as development, operations, security, and compliance. The Accelerators for Teams feature in <a href="https://developer.ibm.com/components/cloud-pak-for-applications/">IBM Cloud Pak for Applications</a> is designed to speed up the development of cloud-native applications by enabling multi-disciplinary teams to codify</p>]]></description><link>http://localhost:2368/design-and-deliver-a-rest-based-cloud-native-application-at-lightning-speed/</link><guid isPermaLink="false">5ee72812c6109770d9cb6dbb</guid><category><![CDATA[cloud]]></category><category><![CDATA[rest]]></category><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Mon, 15 Jun 2020 07:57:46 GMT</pubDate><content:encoded><![CDATA[<h2 id="introduction">Introduction</h2><p>For a software delivery project to be successful, alignment is required across multiple enterprise disciplines, such as development, operations, security, and compliance. The Accelerators for Teams feature in <a href="https://developer.ibm.com/components/cloud-pak-for-applications/">IBM Cloud Pak for Applications</a> is designed to speed up the development of cloud-native applications by enabling multi-disciplinary teams to codify and centrally manage decisions, improving the end-to-end journey from a business problem to a production application. The article <em><em><a href="https://developer.ibm.com/articles/introduction-to-accelerators-for-cloud-native-solutions">Introduction to accelerators for cloud-native solutions</a></em></em> explains the full value proposition behind Accelerators for Teams and how you can leverage this innovative technology to expedite development.</p><p>This tutorial covers the new Accelerator for Cloud-native Apps, demonstrating how you can use one of the <em><em>Reference Blueprints</em></em> to quickly move from design to deployment of an app that contains only sample REST-based microservices. Before starting the tutorial, let’s cover a few basics.</p><h3 id="the-advantages-of-a-cloud-native-architecture">The advantages of a cloud-native architecture</h3><p><em><em>Cloud-native</em></em> is an industry term that is used to describe applications that are architected, built, and optimized to run on the cloud. Cloud-native applications are typically implemented as loosely-coupled microservices, run in containers, and managed by an orchestration system such as Kubernetes. By nature, these applications are elastic, meaning that they can scale autonomously based on the demand that is placed on an application. They are also portable between different clouds. Cloud-native applications take advantage of modern software delivery practices such as continuous integration (CI), continuous delivery (CD), DevOps, and GitOps.</p><p>Here are some of the advantages of moving to a cloud-native architecture:</p><ul><li>Loose coupling between microservices</li><li>Lightweight services with a small code base</li><li>Elasticity</li><li>Portability</li><li>Language agnostic</li><li>Integration with continuous integration and continuous delivery (CI/CD) systems</li></ul><p>The IBM Cloud Architecture Center hosts a full <a href="https://www.ibm.com/cloud/architecture/architectures/cloud-native">reference architecture for cloud-native solutions</a>, which contains some valuable resources for developing cloud-native applications.</p><p>The Accelerator for Cloud-native Apps, a technology preview in IBM Cloud Pak for Applications v4.2, provides an end-to-end workflow for developing REST-based microservice applications. REST-based microservices communicate with each other over HTTP, using APIs typically defined in an OpenAPI specification document.</p><p>By using the Accelerator for Cloud-native Apps, a solution architect can design a microservice application architecture comprised of REST-based microservices based on Open Liberty, Spring, Quarkus, and Node.js technologies. The architect can also specify how the microservices interact with each other within a complete topology. Then, skeleton Git repositories can be generated for each microservice, alongside a GitOps repository so that the complete application can be automatically generated, ready for deployment via continuous delivery pipelines.</p><p>The Accelerator for Cloud-native Apps provides a <em><em>Reference Blueprint</em></em> for the StoreFront application that implements a REST-based microservice scenario.</p><h3 id="about-the-storefront-reference-blueprint">About the StoreFront Reference Blueprint</h3><p>The StoreFront blueprint is based on the IBM Cloud reference architecture for BlueCompute, which is illustrated in the following diagram:</p><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/tutorials/accelerator-for-cloud-native-apps/images/storefront-blueprint.jpg" class="kg-image" alt="Detailed reference architecture diagram illustrating a Web Backend for Frontend (`webbff`) microservice connected to backend microservices, which are in turn, connected to backend microservices. More information is provided in the text that follows."></figure><p>The blueprint represents an application for online shopping. Customers can browse through a catalog that contains a selection of antique computing devices and make a purchase.</p><p>You can learn more about BlueCompute in the IBM Cloud Architecture Center. See <em><em><a href="https://www.ibm.com/cloud/architecture/architectures/deploy-retail-app-on-openshift">Deploy a retail application on RedHat OpenShift</a></em></em>.</p><h2 id="prerequisites">Prerequisites</h2><p>To work through this tutorial you must have the following pre-requisites in place:</p><ul><li>Install <a href="https://www.ibm.com/support/knowledgecenter/SSCSJL_4.2.x/install-icpa-cli.html">IBM Cloud Pak for Applications v4.2</a>.</li><li>Install the <a href="https://www-.ibm.com/support/knowledgecenter/SSCSJL_4.2.x/techpreview/installing.html">Accelerator technology preview</a>.</li><li>Create a <a href="https://github.com/">GitHub</a> account.</li></ul><h2 id="estimated-time">Estimated time</h2><p>Completing this tutorial should take about 30 minutes.</p><h2 id="steps">Steps</h2><p>To demonstrate how the Accelerator for Cloud-native Apps can help speed up application development and deployment, the following tutorial steps walk you through an end-to-end workflow that uses the StoreFront Reference Blueprint.</p><h3 id="step-1-create-a-github-organization-for-the-storefront-artifacts">Step 1: Create a GitHub organization for the StoreFront artifacts</h3><ul><li>In GitHub, click your GitHub profile picture, then click <strong>Settings</strong>.</li><li>Under <strong>Personal settings</strong>, click <strong>Organizations</strong>.</li><li>Click <strong>New Organization</strong>.</li><li>In the <strong>Organization name</strong> field, enter <code>my-storefront</code>.</li><li>Click <strong>Create organization</strong>, then click <strong>Finish</strong>.</li></ul><h3 id="step-2-load-the-accelerator-reference-blueprint-for-the-storefront-application">Step 2: Load the Accelerator Reference Blueprint for the StoreFront application</h3><ul><li>From your IBM Cloud Pak for Applications landing page, click <strong>Build Solution</strong> to start the Solution Builder tool.</li><li>Load the StoreFront Reference Blueprint onto the canvas by clicking <strong>New Blueprint</strong> and choose <strong>(Ref) StoreFront</strong> from the list of available blueprints.</li></ul><p>From the menu bar, click <strong>More Options &gt; Save As</strong>, enter a new name, and save your own copy of the blueprint as shown in the following screen capture:</p><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/tutorials/accelerator-for-cloud-native-apps/images/storefront-save-as.jpg" class="kg-image" alt="The Solution Builder user interface, showing the **More Options** menu and the StoreFront application topology"></figure><p>The screen capture also shows the application topology. The Web Backend for Frontend (<code>webbff</code>) microservice provides the user interface to the online store. This REST-based microservice binds to four other REST-based microservices that are responsible for querying customer records, items in the shopping catalog, order records, and inventory records. Each microservice has its own backend database.</p><p>Click each of the components in turn to discover the configuration settings:</p><ul><li>The <code>webbff</code> component is configured to build a microservice from the Node.js Express application stack.</li><li>The <code>Customer</code>, <code>Catalog</code>, <code>Order</code>, and <code>Inventory</code> components are configured to build microservices from the <a href="https://developer.ibm.com/components/open-liberty/">Open Liberty</a> application stack. Each microservice connects to a backend database.</li><li>All the backend databases run on PostgresSQL 11.</li></ul><h3 id="step-3-add-configuration-details-for-github">Step 3: Add configuration details for GitHub</h3><ul><li>From the menu bar, click <strong>Blueprint properties</strong> and add the URL for your GitHub organization in the <strong>Git Properties</strong> field, as shown in the following diagram:</li></ul><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/06/storefront-properties.jpg" class="kg-image" srcset="http://localhost:2368/content/images/size/w600/2020/06/storefront-properties.jpg 600w, http://localhost:2368/content/images/size/w1000/2020/06/storefront-properties.jpg 1000w, http://localhost:2368/content/images/size/w1600/2020/06/storefront-properties.jpg 1600w, http://localhost:2368/content/images/size/w2400/2020/06/storefront-properties.jpg 2400w"></figure><ul><li>Uncheck the boxes for adding GitOps staging and production environments.</li><li>Click <strong>Save</strong> to save your changes in the <strong>Blueprint Properties</strong> pane.</li><li>From the menu bar, click the <strong>Save Blueprint</strong> icon to save your Solution Blueprint.</li></ul><h3 id="step-4-generate-the-repositories-on-github">Step 4: Generate the repositories on GitHub</h3><ul><li>Generate a GitHub personal access token on GitHub that gives you full control of any repositories in your organization and copy it to your clipboard. For help, see <em><em><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a></em></em>.</li><li>In Solution Builder, click <strong>Generate</strong>.</li><li>When asked for your GitHub credentials, enter your GitHub user ID and paste your Personal Access Token into the <strong>Git Token</strong> field.</li><li>Click <strong>Generate</strong> again.</li></ul><p>As Solution Builder generates the repositories, an <strong>Execution window</strong> indicates progress. Running processes are shown in light green and turn to dark green when complete.</p><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/tutorials/accelerator-for-cloud-native-apps/images/storefront-execution.jpg" class="kg-image" alt="Diagram of the Execution Window, which  is explained in the surrounding text"></figure><h3 id="step-5-check-that-all-the-github-repositories-were-generated-successfully">Step 5: Check that all the GitHub repositories were generated successfully</h3><p>Go to your GitHub organization to view the repositories.</p><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/tutorials/accelerator-for-cloud-native-apps/images/storefront-git-repo.jpg" class="kg-image" alt="Diagram of the GitHub organization with all the repositories that make up the application"></figure><p>A GitHub code repository is created for each microservice in the StoreFront application.</p><p>Each microservice repository contains an <code>app-deploy.yaml</code> file, which is the configuration file that is used by the <em><em>Appsody Operator</em></em> to deploy a project. You can see information about the application stack and the endpoints exposed for the microservice. The following section from the <code>app-deploy.yaml</code> file in the <code>webbff</code> repository identifies the <code>webbff</code> microservice as part of the StoreFront application, running on the <code>nodejs-express</code> stack, v 0.4.8.</p><pre><code>...
labels:
  app.kubernetes.io/part-of: storefront
  image.opencontainers.org/title: webbff
  stack.appsody.dev/id: nodejs-express
  stack.appsody.dev/version: 0.4.8
name: webbff
...</code></pre><p>A single GitOps repository, <code>gitops-dev</code>, is also created that contains configuration information for the development deployment environment.</p><p>In the <code>gitops-dev</code> repository, the <code>environments/storefront-dev/env/base/namespace.yaml</code> shows that the target namespace for the application is <code>storefont-dev</code>.</p><pre><code>apiVersion: v1
kind: Namespace
metadata:
  name: storefront-dev</code></pre><p>The repositories contain the scaffolding for the application. The microservices repositories contain sample code that runs and the GitOps repository contains the configuration to deploy all of the microservices and establish the bindings to the PostgresSQL database. At this stage, the business logic to drive the StoreFront application is missing. However, to learn how to implement the end-to-end workflow, you can continue to deploy the application in its present state.</p><h3 id="step-6-preparing-your-deployment-environment">Step 6: Preparing your deployment environment</h3><p>......................................</p>]]></content:encoded></item><item><title><![CDATA[Deploy Spring Boot microservices on Kubernetes]]></title><description><![CDATA[<h2 id="summary">Summary</h2><p>Spring Boot is an opinionated framework for quickly building production-ready Spring applications. This pattern shows you how to create and deploy Spring Boot microservices within a polyglot application and then deploy the app to a Kubernetes cluster.</p><h2 id="description">Description</h2><p>The Java community is finding innovative ways to use technologies like</p>]]></description><link>http://localhost:2368/deploy-spring-boot-microservices-on-kubernetes/</link><guid isPermaLink="false">5ee6f12ba9bc1715a4b41003</guid><category><![CDATA[spring]]></category><category><![CDATA[kubernetes]]></category><dc:creator><![CDATA[dungbv]]></dc:creator><pubDate>Mon, 15 Jun 2020 03:55:44 GMT</pubDate><content:encoded><![CDATA[<h2 id="summary">Summary</h2><p>Spring Boot is an opinionated framework for quickly building production-ready Spring applications. This pattern shows you how to create and deploy Spring Boot microservices within a polyglot application and then deploy the app to a Kubernetes cluster.</p><h2 id="description">Description</h2><p>The Java community is finding innovative ways to use technologies like Java EE within microservices architectures. The Spring framework is an established presence in the Java ecosystem, and now Spring Boot is garnering a lot of attention because it radically simplifies writing a Spring application.</p><p>Spring Boot takes an opinionated view of building Spring applications. You can use Spring Boot to create stand-alone Java applications that can be started using the Java <code>-jar</code> command or more traditional WAR deployments. Spring applications can be deployed as WAR files atop existing app servers, or they can be built into a “fat” JAR file with an embedded app server. Either choice works well within a Docker container. You can then rely on native Spring platforms like Spring Cloud to perform tasks such as service discovery, registration, and load balancing.</p><p>But what do we do in the context of polyglot applications? For managing a system of polyglot microservices, you need a general-purpose microservices and container orchestration platform, and that’s where Kubernetes shines. In this developer pattern, you’ll build an app called Office Space — and yes, it’s inspired by Michael Bolton’s idea in the movie “Office Space.” When you complete the pattern, you’ll understand how to deploy a polyglot microservices application, including Spring Boot microservices, on a Kubernetes cluster.</p><h2 id="flow">Flow</h2><figure class="kg-card kg-image-card"><img src="https://developer.ibm.com/developer/patterns/deploy-spring-boot-microservices-on-kubernetes/images/Deploy-Spring-Boot-microservices-on-Kubernetes.png" class="kg-image" alt="flow"></figure><ol><li>The Transaction Generator service written in Python simulates transactions and pushes them to the Compute Interest microservice.</li><li>The Compute Interest microservice computes the interest and then moves the fraction of pennies to the MySQL database to be stored.</li><li>The database can be running within a container in the same deployment or on a public cloud such as IBM Cloud.</li><li>The Compute Interest microservice then calls the notification service to notify the user if an amount has been deposited in the user’s account.</li><li>The Notification service uses OpenWhisk actions to send an email message to the user. You can also invoke an OpenWhisk action to send messages to Slack.</li><li>Additionally, an OpenWhisk action to send messages to Slack can also be invoked.</li><li>The user retrieves the account balance by visiting the Node.js web interface.</li></ol>]]></content:encoded></item></channel></rss>